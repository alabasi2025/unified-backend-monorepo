// PHASE-15: Smart Journal Entries System - Main Service
// This service handles smart journal entry creation and validation

import { Injectable, NotFoundException, BadRequestException } from '@nestjs/common';
import { PrismaService } from '../../../1-core-services/prisma/prisma.service';
import {
  CreateJournalEntryFromTemplateDto,
  CreateJournalEntryFromOperationDto,
  ValidateJournalEntryDto,
  JournalEntryValidationResultDto,
  AutomatedJournalEntryDto,
  SmartJournalEntryStatsDto, // Added DTO for stats
} from '@semop/contracts';
import { JournalEntryTemplateService } from './journal-entry-template.service';
import { SmartLearningService } from './smart-learning.service';

@Injectable()
export class SmartJournalEntryService {
  constructor(
    private readonly prisma: PrismaService,
    private readonly templateService: JournalEntryTemplateService,
    private readonly learningService: SmartLearningService,
  ) {}

  /**
   * Get smart journal entry statistics
   */
  async getStats(): Promise<SmartJournalEntryStatsDto> {
    // 1. totalTemplates: Total number of active journal entry templates
    const totalTemplates = await this.prisma.journalEntryTemplate.count({
      where: { isActive: true },
    });

    // 2. totalAutomatedEntries: Total number of automated journal entries
    const totalAutomatedEntries = await this.prisma.automatedJournalEntry.count();

    // 3. totalManualOverrides: Number of automated entries that were manually modified (isAutoGenerated = false)
    const totalManualOverrides = await this.prisma.automatedJournalEntry.count({
      where: { isAutoGenerated: false },
    });

    // 4. learningSuccessRate: Percentage of automated entries that were not manually overridden
    let learningSuccessRate = 0;
    if (totalAutomatedEntries > 0) {
      const successfulEntries = totalAutomatedEntries - totalManualOverrides;
      learningSuccessRate = (successfulEntries / totalAutomatedEntries) * 100;
    }

    // 5. lastLearningUpdate: Timestamp of the last time the smart learning model/rules were updated.
    // Using the latest update from SmartLearningLog
    const lastLearningLog = await this.prisma.smartLearningLog.findFirst({
      orderBy: { updatedAt: 'desc' },
      select: { updatedAt: true },
    });

    const lastLearningUpdate = lastLearningLog?.updatedAt || new Date(0); // Default to epoch if no logs

    return {
      totalTemplates,
      totalAutomatedEntries,
      totalManualOverrides,
      learningSuccessRate: parseFloat(learningSuccessRate.toFixed(2)),
      lastLearningUpdate,
    };
  }

  /**
   * Create journal entry from template
   */
  async createFromTemplate(dto: CreateJournalEntryFromTemplateDto): Promise<AutomatedJournalEntryDto> {
    // Get template
    const template = await this.templateService.findOne(dto.templateId);

    if (!template.lines || template.lines.length === 0) {
      throw new BadRequestException('Template has no lines');
    }

    // Build journal entry lines from template
    const lines = [];
    let totalDebit = 0;
    let totalCredit = 0;

    for (const templateLine of template.lines) {
      // Get account ID (from template or placeholder)
      let accountId = templateLine.accountId;
      
      if (!accountId && templateLine.accountPlaceholder) {
        // Resolve placeholder from source data
        accountId = this.resolvePlaceholder(templateLine.accountPlaceholder, dto.sourceData);
      }

      if (!accountId) {
        throw new BadRequestException(
          `Cannot resolve account for line ${templateLine.lineOrder}`
        );
      }

      // Get amount from source data
      const amount = this.getAmountFromSource(templateLine.amountSource, dto.sourceData);

      if (amount <= 0) {
        throw new BadRequestException(
          `Invalid amount for line ${templateLine.lineOrder}: ${amount}`
        );
      }

      // Build description
      const description = this.buildDescription(
        templateLine.descriptionTemplate,
        dto.sourceData,
        dto.description
      );

      // Add line
      const line: any = {
        accountId,
        description,
      };

      if (templateLine.accountType === 'debit') {
        line.debit = amount;
        line.credit = 0;
        totalDebit += amount;
      } else {
        line.debit = 0;
        line.credit = amount;
        totalCredit += amount;
      }

      lines.push(line);
    }

    // Validate balance
    if (Math.abs(totalDebit - totalCredit) > 0.01) {
      throw new BadRequestException(
        `Journal entry is not balanced: Debit=${totalDebit}, Credit=${totalCredit}`
      );
    }

    // Create journal entry
    const journalEntry = await this.prisma.$queryRaw`
      INSERT INTO journal_entries (
        id, entry_number, entry_date, description, 
        total_debit, total_credit, status, 
        fiscal_year_id, fiscal_period_id, created_at
      )
      VALUES (
        gen_random_uuid(),
        ${this.generateEntryNumber()},
        ${dto.entryDate || new Date()},
        ${dto.description || template.nameAr},
        ${totalDebit},
        ${totalCredit},
        'DRAFT',
        ${dto.fiscalYearId || null},
        ${dto.fiscalPeriodId || null},
        NOW()
      )
      RETURNING id
    `;

    const journalEntryId = (journalEntry as any[])[0].id;

    // Create journal entry lines
    for (const line of lines) {
      await this.prisma.$executeRaw`
        INSERT INTO journal_entry_lines (
          id, journal_entry_id, account_id, 
          debit, credit, description, created_at
        )
        VALUES (
          gen_random_uuid(),
          ${journalEntryId},
          ${line.accountId},
          ${line.debit},
          ${line.credit},
          ${line.description},
          NOW()
        )
      `;

      // Record usage for learning
      await this.learningService.recordUsage({
        operationType: template.operationType,
        accountId: line.accountId,
      });
    }

    // Create automated journal entry record
    const automatedEntry = await this.prisma.automatedJournalEntry.create({
      data: {
        journalEntryId,
        sourceType: dto.sourceData.sourceType || 'manual',
        sourceId: dto.sourceData.sourceId || journalEntryId,
        templateId: dto.templateId,
        isAutoGenerated: true,
      },
    });

    return {
      id: automatedEntry.id,
      journalEntryId: automatedEntry.journalEntryId,
      sourceType: automatedEntry.sourceType,
      sourceId: automatedEntry.sourceId,
      templateId: automatedEntry.templateId || undefined,
      isAutoGenerated: automatedEntry.isAutoGenerated,
      createdAt: automatedEntry.createdAt,
    };
  }

  /**
   * Create journal entry from operation (auto-detect template)
   */
  async createFromOperation(dto: CreateJournalEntryFromOperationDto): Promise<AutomatedJournalEntryDto> {
    // Find template by operation type
    const template = await this.templateService.findByOperationType(dto.operationType);

    if (!template) {
      throw new NotFoundException(
        `No template found for operation type: ${dto.operationType}`
      );
    }

    // Create from template
    return this.createFromTemplate({
      templateId: template.id,
      sourceData: {
        ...dto.sourceData,
        sourceType: dto.sourceType,
        sourceId: dto.sourceId,
      },
      entryDate: dto.entryDate,
      description: dto.description,
      fiscalYearId: dto.fiscalYearId,
      fiscalPeriodId: dto.fiscalPeriodId,
    });
  }

  /**
   * Validate journal entry
   */
  async validateJournalEntry(dto: ValidateJournalEntryDto): Promise<JournalEntryValidationResultDto> {
    const errors: string[] = [];
    const warnings: string[] = [];

    let totalDebit = 0;
    let totalCredit = 0;

    // Validate lines
    for (const line of dto.lines) {
      totalDebit += line.debit;
      totalCredit += line.credit;

      // Check if account exists
      const accountExists = await this.prisma.$queryRaw`
        SELECT id FROM accounts WHERE id = ${line.accountId} LIMIT 1
      `;

      if (!accountExists || (Array.isArray(accountExists) && accountExists.length === 0)) {
        errors.push(`Account ${line.accountId} does not exist`);
      }

      // Check if line has both debit and credit
      if (line.debit > 0 && line.credit > 0) {
        errors.push(`Line cannot have both debit and credit`);
      }

      // Check if line has neither debit nor credit
      if (line.debit === 0 && line.credit === 0) {
        warnings.push(`Line has zero amount`);
      }
    }

    // Check balance
    const isBalanced = Math.abs(totalDebit - totalCredit) < 0.01;

    if (!isBalanced) {
      errors.push(`Entry is not balanced: Debit=${totalDebit}, Credit=${totalCredit}`);
    }

    // Check fiscal year
    if (dto.fiscalYearId) {
      const fiscalYear = await this.prisma.$queryRaw`
        SELECT id, status FROM fiscal_years WHERE id = ${dto.fiscalYearId} LIMIT 1
      `;

      if (!fiscalYear || (Array.isArray(fiscalYear) && fiscalYear.length === 0)) {
        errors.push(`Fiscal year ${dto.fiscalYearId} does not exist`);
      } else {
        const fy = (fiscalYear as any[])[0];
        if (fy.status === 'CLOSED') {
          errors.push(`Fiscal year is closed`);
        }
      }
    }

    return {
      isValid: errors.length === 0,
      errors,
      warnings,
      totalDebit,
      totalCredit,
      isBalanced,
    };
  }

  /**
   * Helper: Resolve placeholder from source data
   */
  private resolvePlaceholder(placeholder: string, sourceData: any): string | null {
    // Simple placeholder resolution (e.g., "customer_account" -> sourceData.customerAccountId)
    const key = placeholder.replace(/_/g, '') + 'Id';
    return sourceData[key] || sourceData[placeholder] || null;
  }

  /**
   * Helper: Get amount from source data
   */
  private getAmountFromSource(amountSource: string, sourceData: any): number {
    return parseFloat(sourceData[amountSource]) || 0;
  }

  /**
   * Helper: Build description from template
   */
  private buildDescription(template: string | undefined, sourceData: any, defaultDescription?: string): string {
    if (!template) {
      return defaultDescription || 'Automated journal entry';
    }

    // Simple template replacement (e.g., "{{customerName}}" -> sourceData.customerName)
    let description = template;
    const matches = template.match(/\{\{([^}]+)\}\}/g);

    if (matches) {
      for (const match of matches) {
        const key = match.replace(/\{\{|\}\}/g, '');
        const value = sourceData[key] || '';
        description = description.replace(match, value);
      }
    }

    return description;
  }

  /**
   * Helper: Generate entry number
   */
  private generateEntryNumber(): string {
    const now = new Date();
    const year = now.getFullYear();
    const month = String(now.getMonth() + 1).padStart(2, '0');
    const day = String(now.getDate()).padStart(2, '0');
    const random = Math.floor(Math.random() * 10000).toString().padStart(4, '0');
    return `JE-${year}${month}${day}-${random}`;
  }
}
